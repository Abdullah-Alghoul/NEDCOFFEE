# -*- coding: utf-8 -*-# Part of Odoo. See LICENSE file for full copyright and licensing details.import timefrom collections import OrderedDictfrom lxml import etreeimport openerp.addons.decimal_precision as dpfrom openerp.osv import fields, osvfrom openerp.tools import DEFAULT_SERVER_DATE_FORMATfrom openerp.tools import float_compare, float_is_zerofrom openerp.tools.translate import _from openerp import tools, SUPERUSER_IDfrom openerp.exceptions import UserError, AccessErrorfrom datetime import datetime, timedeltafrom openerp import apiclass mrp_bom(osv.osv):    _inherit = 'mrp.bom'    _order = 'last_revised desc, id desc'        def name_get(self, cr, uid, ids, context=None):        res = []        for record in self.browse(cr, uid, ids, context=context):#             if not record.product_tmpl_id.name:#                 name = record.code#             else:#                 name = record.product_tmpl_id.name#                 name = '[%s] %s' % (record.code, name)            #Kiet: Refine name            name = record.code            res.append((record.id, name))        return res    _columns = {              'product_tmpl_id': fields.many2one('product.template', 'Product', domain="[('type', 'in', ['product', 'consu'])]"),              'type': fields.selection([('normal', 'Main product'), ('no', 'No main product')], 'BoM Type', required=True),              'last_revised': fields.date('Last Revised'),              'crop_id':fields.many2one('ned.crop',string = 'Crop')              }        def _check_off_topic(self, cr, uid, ids, context=None):        for bom in self.browse(cr, uid, ids, context=context):            off_topic = 0.0            for line in bom.bom_stage_output_line:                off_topic += line.off_topic or 0.0            if off_topic > 100:                return False        return True        _constraints = [        (_check_off_topic, 'Total off topics is not greater than 100%.', ['bom_stage_output_line']),        ]        def _get_uom_id(self, cr, uid, ids, context=None):        uom_ids = self.pool.get('product.uom').search(cr, uid, [('id', '=', 7)])        return uom_ids and uom_ids[0]        _defaults = {'type': 'normal', 'last_revised' :time.strftime('%Y-%m-%d %H:%M:%S'),               'product_uom': _get_uom_id}                mrp_bom()class direct_labour(osv.osv):    _inherit = 'direct.labour'        _columns = {               'ot_hour': fields.float('Number of OT Hours'),               }    class mrp_bom_stage_line(osv.osv):    _inherit = 'mrp.bom.stage.line'    _columns = {               'cycle_nbr': fields.float('Number of Cycles'),               'hour_nbr': fields.float('Number of Hours'),               'product_qty': fields.float('Product qty'),               'ot_hour': fields.float('Number of OT Hours'),               }        def onchange_product_id(self, cr, uid, ids, product_id, context=None):        res = {}        if product_id:            product = self.pool.get('product.product').browse(cr, uid, product_id)            res = {'product_uom': product}        return {'value': res}mrp_bom_stage_line()class mrp_bom_stage_material_line(osv.osv):    _inherit = 'mrp.bom.stage.material.line'    _columns = {             'name': fields.char('Description', size=128, required=True),             'product_qty': fields.float('Product qty'),             'product_id': fields.many2one('product.product', 'Product', required=False),             'categ_id': fields.many2one('product.category', 'Category'),             'off_topic': fields.float('O/T(%)')               }        def onchange_product_id(self, cr, uid, ids, product_id, context=None):        res = {}        if not product_id:            return res        product_obj = self.pool.get('product.product').browse(cr, uid, product_id)        res = {'product_uom': product_obj.uom_id.id or False, 'name': product_obj.description_sale or ''}        return {'value': res}    mrp_bom_stage_material_line()class mrp_bom_stage_output_line(osv.osv):    _inherit = 'mrp.bom.stage.output.line'    _columns = {              'off_topic': fields.float('O/T(%)'),              'product_qty': fields.float('Product qty'),              'categ_id': fields.many2one('product.category', 'Category')               }        _defaults = { 'off_topic': 0.0}                  mrp_bom_stage_output_line()class mrp_production(osv.osv):    _inherit = 'mrp.production'    _columns = {                'product_id': fields.many2one('product.product', 'Product', readonly=True, states={'draft': [('readonly', False)]},required=False, domain=[('type', 'in', ['product', 'consu'])]),                'type_produced': fields.selection([('normal', 'Main product'), ('no', 'No main product')], 'Type', required=False, readonly=True, states={'draft': [('readonly', False)]}),            }        _defaults = {'type_produced': 'normal'}        def calculate_processtime(self, cr, uid, work_order):        ldc_ProcessHour = 360        return ldc_ProcessHour        def create_materials(self, cr, uid, production, list_operation_code={}):        prod_line_obj = self.pool.get('mrp.production.product.line')        meterials_ids = []        for bom_stage in production.bom_id.bom_stage_lines:            for material in bom_stage.bom_stage_material_line:                prod_line_obj.create(cr, uid, {'name': material.product_id.name_template, 'product_id': material.product_id.id,                                       'product_uom': material.product_uom.id, 'production_id': production.id, 'product_qty': 1})        def create_workcenter_line(self, cr, uid, production):        workcenter_line_obj = self.pool.get('mrp.production.workcenter.line')        produce_obj = self.pool.get('mrp.production.workcenter.product.produce')        output_ids = []        for bom_stage in production.bom_id.bom_stage_lines:            name = production.bom_id.code + '-' + production.name + '-' + bom_stage.production_stage_id.code or 'New'            vals = {'name': name, 'production_id': production.id or False, 'congdoan_id': bom_stage.production_stage_id.id or False,                  'workcenter_id': bom_stage.workcenter_id.id or False, 'location_src_id': production.location_src_id.id or False,                  'location_dest_id': production.location_dest_id.id or False}            workcenter_line_id = workcenter_line_obj.create(cr, uid, vals)            for output in bom_stage.bom_stage_output_line:                produce_obj.create(cr, uid, {'product_id': output.product_id.id or False,                    'product_uom': output.product_uom.id or False, 'operation_id': workcenter_line_id or False})                    def action_compute(self, cr, uid, ids, properties=None, context=None):        prod_line_obj = self.pool.get('mrp.production.product.line')        workcenter_line_obj = self.pool.get('mrp.production.workcenter.line')        for production in self.browse(cr, uid, ids):            prod_line_obj.unlink(cr, SUPERUSER_ID, [line.id for line in production.product_lines], context=context)            list_operation_code = {}            if len(production.workcenter_lines):                workcenter_line_obj.unlink(cr, SUPERUSER_ID, [line.id for line in production.workcenter_lines], context=context)                        if production.bom_id:                self.create_materials(cr, uid, production, list_operation_code=list_operation_code)                self.create_workcenter_line(cr, uid, production)        return True    #     def onchange_type_produced(self, cr, uid, ids, type_produced, context=None):#         domain = {}#         bom_ids = []#         #         bom_obj = self.pool.get('mrp.bom')#         if type_produced == 'no':#             bom_ids = bom_obj.search(cr, uid, [('type', '=', 'no')])#             if bom_ids:#                 domain.update({'bom_id': [('id', '=', bom_ids)]})#         else:#             bom_ids = bom_obj.search(cr, uid, [('type', '=', 'normal')])#             if bom_ids:#                 domain.update({'bom_id': [('id', '=', bom_ids)]})#         return {'domain': domain}        def product_id_change(self, cr, uid, ids, product_id, type_produced, product_qty=0, context=None):        result = {}        bom_ids = []        bom_obj = self.pool.get('mrp.bom')        if type_produced == 'normal':            if not product_id:                bom_ids = bom_obj.search(cr, uid, [('type', '=', 'normal')])                return {'value': {'product_uom': False, 'bom_id': False, 'routing_id': False, 'product_tmpl_id': False },                        'domain': {'bom_id': [('id','=',bom_ids)]}}            product = self.pool.get('product.product').browse(cr, uid, product_id, context=context)            bom_id = bom_obj._bom_find(cr, uid, product_id=product.id, properties=[], context=context)            routing_id = False            if bom_id:                bom_point = bom_obj.browse(cr, uid, bom_id, context=context)                routing_id = bom_point.routing_id.id or False            product_uom_id = product.uom_id and product.uom_id.id or False            result['value'] = {'product_uom': product_uom_id, 'bom_id': bom_id, 'routing_id': routing_id, 'product_tmpl_id': product.product_tmpl_id}            bom_ids = bom_obj.search(cr, uid, [('type', '=', 'normal'), ('product_id', '=', product_id)])            if bom_ids:                result['domain'] = {'bom_id': [('id', '=', bom_ids)]}        else:            if not product_id:                bom_ids = bom_obj.search(cr, uid, [('type', '=', 'no')])                return {'value': {'product_uom': False, 'bom_id': False, 'routing_id': False, 'product_tmpl_id': False },                        'domain': {'bom_id': [('id','=',bom_ids)]}}        return result        def bom_id_change(self, cr, uid, ids, bom_id, type_produced, context=None):        if not bom_id:            return {'value': {                'routing_id': False             }}        bom_point = self.pool.get('mrp.bom').browse(cr, uid, bom_id, context=context)        routing_id = bom_point.routing_id.id or False        product_uom_id = False        if type_produced == 'no':            for stage_line in bom_point.bom_stage_lines:                for output in stage_line.bom_stage_output_line:                    if output.sequence == 1:                        product_uom_id = output.product_uom.id or False            result = {'routing_id': routing_id, 'product_uom': product_uom_id}        else:            result = {'routing_id': routing_id, 'product_id': bom_point.product_id.id, 'product_uom': bom_point.product_uom.id}        return {'value': result}        def action_ready(self, cr, uid, ids, context=None):        proc_obj = self.pool.get('procurement.order')        move_obj = self.pool.get('stock.move')        for production in self.browse(cr, uid, ids, context=context):            if not len(production.product_lines) or not len(production.workcenter_lines):                error = "Lack of information on raw materials for production."                raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))#             for line in production.workcenter_lines:#                 if not line.date_planned or not line.date_planned_end: #                     error = "Information about Time is scheduled to begin and is expected to end the production requirements have not been created."#                     raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))                        warehouse_obj = self.pool.get('stock.warehouse').browse(cr, uid, production.warehouse_id.id)            if not production.move_created_ids:                destination_location_id = production.location_dest_id.id                for line in production.workcenter_lines:                     for produced in line.produce_ids:                        product_id = produced.product_id.id                        product_uom = produced.product_uom.id                        source_location_id = produced.product_id.property_stock_production.id                        procs = proc_obj.search(cr, uid, [('production_id', '=', production.id)], context=context)                        procurement = procs and proc_obj.browse(cr, uid, procs[0], context=context) or False                        data = {'name': production.name, 'date': production.date_planned,                            'product_id': product_id, 'product_uom': product_uom,                             'picking_type_id': warehouse_obj.production_in_type_id.id,                            'product_uom_qty': 1, 'location_id': source_location_id,                             'group_id': procurement and procurement.group_id.id,                            'location_dest_id': destination_location_id, 'move_dest_id': production.move_prod_id.id,                            'procurement_id': procurement and procurement.id, 'company_id': production.company_id.id,                            'production_id': production.id, 'origin': production.name, 'state': 'waiting'}                        move_id = move_obj.create(cr, uid, data, context=context)#                 production.write({'move_created_ids': [(6, 0, [move_id])]}, context=context)                    if production.move_prod_id and production.move_prod_id.location_id.id != production.location_dest_id.id:                        move_obj.write(cr, uid, [production.move_prod_id.id], {'location_id': production.location_dest_id.id})            self.write(cr, uid, ids, {'state': 'in_production'})    mrp_production()class mrp_production_workcenter_line(osv.osv):    _inherit = 'mrp.production.workcenter.line'    _columns = {              'produce_ids': fields.one2many('mrp.production.workcenter.product.produce', 'operation_id', 'Product to Produce', readonly=True),              'workcenter_consumed_ids': fields.one2many('mrp.production.workcenter.consumed.produce', 'operation_id', 'Product to Produce', readonly=True)              }        def action_done(self, cr, uid, ids, context=None):        production_pool = self.pool.get('mrp.production')        consumed_obj = self.pool.get('mrp.production.workcenter.product.consumed')        for operation in self.browse(cr, uid, ids):            delay = 0.0            date_finished = time.strftime('%Y-%m-%d %H:%M:%S')            dem = 0            for result in operation.production_results:                dem += 1                if dem == len(operation.production_results):                    date_finished = result.end_date                    break            date_start = datetime.strptime(operation.date_start, '%Y-%m-%d %H:%M:%S')            date_finished = datetime.strptime(date_finished, '%Y-%m-%d %H:%M:%S')            delay += (date_finished - date_start).days * 24            delay += (date_finished - date_start).seconds / float(60 * 60)                        self.write(cr, uid, [operation.id], {'state':'done', 'date_finished': date_finished, 'delay':delay}, context=context)        self.signal_workflow(cr, uid, [result.operation_id.id], 'button_done')        self.modify_production_order_state(cr, uid, ids, 'done')        return Truemrp_production_workcenter_line()class mrp_production_workcenter_product_produce(osv.osv):    _name = 'mrp.production.workcenter.product.produce'    _columns = {              'product_id': fields.many2one('product.product', 'Product', required=True),              'product_uom': fields.many2one('product.uom', 'Uom', required=True),              'operation_id': fields.many2one('mrp.production.workcenter.line', 'Operation', ondelete='cascade', select=True),              }    mrp_production_workcenter_product_produce()    class mrp_operation_result(osv.osv):    _inherit = 'mrp.operation.result'    _order = 'id desc'        _columns = {              'product_id': fields.many2one('product.product', 'Product', readonly=True, states={'draft': [('readonly', False)]}),              'product_uom': fields.many2one('product.uom', 'UoM', readonly=True, states={'draft': [('readonly', False)]}),              'production_shift':fields.selection([                        ('1','Ca 1'),                        ('2','Ca 2'),                        ('3','Ca 3'),], 'Ca', required=True, default="1" ),    }        @api.model    def create(self, vals):        result = super(mrp_operation_result, self).create(vals)        return result                def button_confirm(self, cr, uid, ids, context=None):        workcenter = self.pool.get('mrp.production.workcenter.line')        move = self.pool.get('stock.move')        operation_produce = self.pool.get('mrp.production.workcenter.product.produce')         operation_consumed = self.pool.get('mrp.production.workcenter.consumed.produce')                for result in self.browse(cr, uid, ids):            if not len(result.produced_products):                error = 'Results of production does not exist.'                raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))                        if not len(result.production_id.move_lines):                error = 'Materials will be consumed not exist.'                raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))                        if result.operation_id.state == 'draft':                if result.finished:                    workcenter.action_start_working(cr, uid, [result.operation_id.id], context=context)                else:                    workcenter.action_start_working(cr, uid, [result.operation_id.id], context=context)                                if result.operation_id.state == 'cancel':                error = "Production requirements ('%s') of this section ('%s') has been canceled." % (str(result.operation_id.name), str(result.operation_id.congdoan_id.type))                raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))                        self.write(cr, uid, [result.id], {'state':'done'})                        if result.finished:                workcenter.action_done(cr, uid, result.operation_id.id)                        production_obj = self.pool.get('mrp.production').browse(cr, uid, result.production_id.id)            company_id = production_obj.company_id.id or False            warehouse_obj = self.pool.get('stock.warehouse').browse(cr, uid, production_obj.warehouse_id.id)            product_qty = 0            for produced in result.produced_products:                if produced.picking_id:                    continue                if produced.product_qty > 0:                                     picking_type_id = warehouse_obj.production_in_type_id.id or False                    picking_type = self.pool.get('stock.picking.type').browse(cr, uid, picking_type_id)                                        if not produced.product_id.property_stock_production.id:                        error = "Production Locations  does not exist."                        raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))                    location_id = produced.product_id.property_stock_production.id                     if not warehouse_obj.wh_production_loc_id.id:                        error = "Location Destination does not exist."                        raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))                    #location_dest_id = warehouse_obj.wh_production_loc_id.id                    location_dest_id = warehouse_obj.wh_finished_good_loc_id.id                    for bom_material in result.operation_id.production_id.bom_id.bom_stage_lines.bom_stage_material_line:                        val ={                            'product_id':bom_material.product_id.id,                            'product_uom':bom_material.product_uom.id,                            'date_consumed':time.strftime('%Y-%m-%d'),                            'operation_result_id':result.id,                            'check_kcs':False,                            'product_qty':0.0,                            'finished_id':produced.id                            }                        self.pool.get('mrp.operation.result.consumed.product').create(cr,uid,val)                                                        product_qty += produced.product_qty                    # Kiệt: Create nhập kho Thành phẩm Thêm Picking để KCS NED                    var = {                        'name':produced.pending_grn or False,                        'picking_type_id': picking_type_id,                        'partner_id': False,                        'date': time.strftime('%Y-%m-%d %H:%M:%S') or False,                        'origin': produced.pending_grn or False,                        'location_dest_id': location_dest_id,                        'location_id': 7,                        'state':'draft',                        'production_id':production_obj.id,                        'operation_id':result.operation_id.id,                        'result_id':result.id,                        'note':produced.notes                    }                    picking_id = self.pool.get('stock.picking').create(cr,uid,var)                    move.create(cr, uid, {'picking_id': picking_id, 'name': produced.product_id.name or '', 'product_id': produced.product_id.id or False,                        'product_uom': produced.product_uom.id or False,                         'init_qty':produced.product_qty or 0.0,                        'product_uom_qty': produced.product_qty or 0.0, 'price_unit': 0.0,                        'picking_type_id': picking_type_id or False, 'location_id': location_id or False, 'production_id': production_obj.id,                        'location_dest_id': location_dest_id or False, 'date_expected': time.strftime('%Y-%m-%d %H:%M:%S') or False,                        'date': time.strftime('%Y-%m-%d %H:%M:%S') or False, 'type': picking_type.code or False, 'result_id': result.id,                        'zone_id':produced.zone_id and produced.zone_id.id or False,                        'packing_id':produced.packing_id.id,                        'bag_no':produced.qty_bags or 0.0,                        'company_id': company_id, 'state':'draft', 'scrapped': False, 'warehouse_id': warehouse_obj.id or False})                    self.pool.get('stock.picking').browse(cr,uid,picking_id).action_confirm()                                        self.pool.get('mrp.operation.result.produced.product').write(cr,uid,[produced.id],{'picking_id':picking_id})                    operation_produce_id = operation_produce.search(cr, uid, [('operation_id','=',result.operation_id.id),('product_id','=',produced.product_id.id)])                    if operation_produce_id:                        operation_produce_obj = operation_produce.browse(cr, uid, operation_produce_id[0])                        operation_produce.write(cr, uid, operation_produce_obj.id , {'check_kcs':False})                    else:                        operation_produce.create(cr, uid, {'check_kcs':False,'product_id': produced.product_id.id or False, 'product_uom': produced.product_uom.id or False,                            'operation_id': result.operation_id.id})                    #           Kiet: Tạo nguyên vật liệu tiêu hao                   for bom_material in result.operation_id.production_id.bom_id.bom_stage_lines.bom_stage_material_line:                operation_consumed_id = operation_consumed.search(cr, uid, [('operation_id','=',result.operation_id.id),('product_id','=',bom_material.product_id.id)])                if operation_consumed_id:                    operation_consumed_obj = operation_consumed.browse(cr, uid, operation_consumed_id[0])                    operation_consumed.write(cr, uid, operation_consumed_obj.id , {'check_kcs':False})                else:                    val = {                        'product_id':bom_material.product_id.id,                        'product_uom':bom_material.product_uom.id,                        'operation_id':result.operation_id.id,                        'check_kcs':False,                        'product_qty':0                    }                    operation_consumed.create(cr,uid,val)                                            return True        def button_cancel(self, cr, uid, ids, context=None):        workcenter = self.pool.get('mrp.production.workcenter.line')        for result in self.browse(cr, uid, ids):            if result.production_id.state == 'done':                error = "Production order %s done." % (str(result.production_id.name))                raise osv.except_osv(unicode('Error!', 'utf8'), unicode(error, 'utf8'))            else:                cr.execute('''DELETE FROM stock_move WHERE result_id = %s;''' % (ids[0]))                cr.execute('''                    DELETE FROM stock_move where id in(                        SELECT move_id FROM mrp_operation_result_consumed_product                         WHERE operation_result_id =%s);                '''%(ids[0]))                cr.execute('''DELETE FROM mrp_operation_result_consumed_product WHERE operation_result_id = %s;'''%(ids[0]))                                                workcenter.write(cr , uid, [result.operation_id.id], {'check_kcs':False})                        operation_id = result.operation_id.id or False            operation_produce = self.pool.get('mrp.production.workcenter.product.produce')                        for produced in result.produced_products:                if produced.product_qty > 0:                     operation_produce_id = operation_produce.search(cr, uid, [('operation_id','=',operation_id),('product_id','=',produced.product_id.id)])                    if operation_produce_id:                        operation_produce_obj = operation_produce.browse(cr, uid, operation_produce_id[0])                        operation_produce.write(cr, uid, operation_produce_obj.id , {'check_kcs':False})                #Kiet:                self.pool.get('stock.picking').action_cancel(cr,uid,[produced.picking_id.id])                if produced.picking_id.id:                #stock_operation = self.pool.get('stock.pack.operation').search(cr,1,[('picking_id','=',produced.picking_id.id)])                #self.pool.get('stock.pack.operation').unlink(cr,uid, stock_operation)                    sql ='''                        DELETE FROM stock_pack_operation where picking_id =%s                    '''%(produced.picking_id.id)                    cr.execute(sql)                                        self.pool.get('stock.picking').unlink(cr,uid,produced.picking_id.id)                                                    self.write(cr, uid, ids, {'state':'cancel'})        return True        def button_load(self, cr, uid, ids, context=None):        produced_product = self.pool.get('mrp.operation.result.produced.product')        for this in self.browse(cr, uid, ids):            if this.operation_id:                cr.execute('''DELETE FROM mrp_operation_result_produced_product WHERE operation_result_id = %s;''' % (this.id))                operation_obj = self.pool.get('mrp.production.workcenter.line').browse(cr, uid, this.operation_id.id)                for produce in operation_obj.produce_ids:                    produced_product.create(cr, uid, {'product_id': produce.product_id.id or False, 'product_qty': 0.0,                                         'product_uom': produce.product_uom.id or False, 'operation_result_id': this.id})        return Truemrp_operation_result()class mrp_operation_result_produced_product(osv.osv):    _inherit = 'mrp.operation.result.produced.product'        def _check_qty(self, cr, uid, ids, context=None):        for produced in self.browse(cr, uid, ids, context=context):            if produced.product_qty <= 0:                return True        return True        _columns = {                'product_qty':fields.float('Product Qty',digits=(12, 0)),                'pending_grn': fields.char('Pending GRN'),                'packing_id': fields.many2one('ned.packing', string='Packing'),                'qty_packing': fields.float('Qty Packing'),                'picking_id': fields.many2one('stock.picking', string='From Processing'),                'state_kcs':fields.related('picking_id','state_kcs', type='selection',                   selection=[('draft','New'),('approved','Approved'),('rejected','Rejected')],string='State Kcs', readonly=True),                'zone_id': fields.many2one('stock.zone', 'Zone', required=False ),                'notes':fields.char(string="Note",size=128),                'kcs_notes':fields.char(string="QC Note",size=128)                }        _defaults={'pending_grn': '/'}                  def _check_pending_grn(self, cr, uid, ids, context=None):        for produced in self.browse(cr, uid, ids, context=context):            produced_id = False            if produced.operation_result_id.state == 'cancel':                return True                        if produced.pending_grn and produced.pending_grn !='/':                produced_id = self.search(cr, uid, [('pending_grn','=',produced.pending_grn),('id','!=',produced.id)])            if produced_id:                return False        return True    #     def write(self,cr, uid, ids, vals, context=None):#         zone_id = False#         product_qty = False#         if vals.get('zone_id',False):#             zone_id = vals['zone_id']#         if not zone_id and ids:#             produced_product =  self.pool.get('mrp.operation.result.produced.product').browse(cr,uid,ids[0])#             zone_id = produced_product.zone_id.id        #         if vals.get('product_qty',False) and vals['product_qty'] != 0:#             product_qty = vals.get('product_qty',False)#         if not product_qty:#             produced_product =  self.pool.get('mrp.operation.result.produced.product').browse(cr,uid,ids[0])#             product_qty = produced_product.product_qty            #         if product_qty and zone_id:#             produced_product = operation_result_id = self.browse(cr,uid,ids[0])#             operation_result_id = produced_product.operation_result_id#             production = operation_result_id.operation_id.production_id or False#             zone = self.pool.get('stock.zone').browse(cr, uid, zone_id)#             #             sql='''SELECT count(morpp.id) number #                     FROM mrp_operation_result mor #                     join mrp_operation_result_produced_product morpp on morpp.operation_result_id = mor.id#                     join mrp_production_workcenter_line mpwl on mpwl.id = mor.operation_id#                 WHERE mpwl.production_id = %s #                     and (pending_grn is null or pending_grn !='/')'''%(production.id)#             cr.execute(sql)#             result = cr.dictfetchall()#             number = result and result[0] and result[0]['number'] or 0#             number = number + 1#             #             obj = self.browse(cr,uid,ids[0])#             if obj.pending_grn and obj.pending_grn !='/':#                 return super(mrp_operation_result_produced_product, self).write(cr, uid, ids, vals, context=context)#             #             if production and zone and number:#                 name = str(production.name) + '-'+ str(zone.name) + '-' + '%%0%sd' % 3 % number #                 vals.update({'pending_grn':name})                    #         return super(mrp_operation_result_produced_product, self).write(cr, uid, ids, vals, context=context)     #     def create(self, cr, uid, vals, context=None):#         if vals.get('product_qty',False) and vals['product_qty'] != 0:#             if vals.get('operation_result_id',False):#                 result = self.pool.get('mrp.operation.result').browse(cr, uid, vals['operation_result_id'])#                  #                 production_id = result.production_id.id or False#                 production = self.pool.get('mrp.production').browse(cr, uid, production_id)#                 zone_id = vals['zone_id'] or False#                 zone = self.pool.get('stock.zone').browse(cr, uid, zone_id)#                  #                 sql='''SELECT count(morpp.id) number #                     FROM mrp_operation_result mor #                     join mrp_operation_result_produced_product morpp on morpp.operation_result_id = mor.id#                     join mrp_production_workcenter_line mpwl on mpwl.id = mor.operation_id#                 WHERE mpwl.production_id = %s #                     and (pending_grn is null or pending_grn !='/')'''%(production.id)#                 cr.execute(sql)#                 result = cr.dictfetchall()#                 number = result and result[0] and result[0]['number'] or 0#                 number = number + 1#                 #                 #                 if production and zone and number:#                     name = str(production.name) + '-'+ str(zone.name) + '-' + '%%0%sd' % 3 % number #                     vals.update({'pending_grn':name})#         return super(mrp_operation_result_produced_product, self).create(cr, uid, vals, context=context)         _constraints = [        (_check_qty, '', ['product_qty']),        #(_check_pending_grn, 'Pending GRN was exist.', ['pending_grn']),        ]mrp_operation_result_produced_product()class stock_picking(osv.osv):    _inherit = 'stock.picking'        def fields_view_get(self, cr, uid, view_id=None, view_type=False, context=None, toolbar=False, submenu=False):        if context is None:            context = {}        res = super(stock_picking, self).fields_view_get(cr, uid, view_id, view_type, context, toolbar, submenu)                if view_type == 'form':            doc = etree.XML(res['arch'])            for node in doc.xpath("//button[@name='button_loading']"):                node.set('attrs', "{'invisible': ['|','|', ('state','&lt;&gt;','done'),('picking_type_code','=','production_in')]}")                        xarch, xfields = self._view_look_dom_arch(cr, uid, doc, view_id, context=context)            res['arch'] = xarch            res['fields'] = xfields        return res        _columns = {        'result_id': fields.many2one('mrp.operation.result',string="Operation Result")    }                stock_picking()